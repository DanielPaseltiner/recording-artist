// $URL: svn://churro.cnbc.cmu.edu/igorcode/Recording%20Artist/Other/ExtractPackedNotebooks.ipf $// $Author: rick $// $Rev: 585 $// $Date: 2011-08-26 09:24:03 -0400 (Fri, 26 Aug 2011) $#pragma rtGlobals=1		// Use modern global access method.//	ExtractPackedNotebooks(pathName, fileName)////	Opens each packed notebook in the specified packed experiment file//	and creates a standalone notebook.////	NOTE: This is a hack that could fail if WaveMetrics changed the packed experiment or formatted notebook file formats.static structure PackedFileInfo	// Iinformation about file stored in a packed file	int16 version;				// version of LumpFileInfo	int16 wType;				// e.g. PROCWIN, MWWIN	char fInfo[16];				// file's finder info	int16 hasDataFork;			// true if file has data fork	int32 numDataBytes;		// length of data fork	int16 hasResFork;			// true if file has resource fork	int32 numResBytes;			// length of resource fork		// These fields are here in case we allow the user to open a file from a lump some day	char fileName31[32];		// Note that this is not large enough for a long Windows file name. The code that deals with this field knows about this.	char winName[32];	char winTitle[42];		int32 laterVersionFPos;	// fPos in lump of a later version of file or 0 if this is the latest		uchar platform;				// 0=unspecified, 1=kMacPlatform, 2=kWinPlatform.		// For possible future expansion	char extra[11];EndStructurestatic Function SwapShort(val)	Variable val	Variable result	result = ((val&0x00FF) * 256) + ((val&0xFF00) / 256)	return resultEndstatic Function SwapLong(val)	Variable val	Variable result = 0	result += (val&0x000000FF) * 16777216	result += (val&0x0000FF00) * 256	result += (val&0x00FF0000) / 256	result += (val&0xFF000000) / 16777216		return resultEndstatic Function SwapPackedFileInfo(pfi)	STRUCT PackedFileInfo &pfi		pfi.version = SwapShort(pfi.version)	pfi.wType = SwapShort(pfi.wType)	pfi.hasDataFork = SwapShort(pfi.hasDataFork)	pfi.numDataBytes = SwapLong(pfi.numDataBytes)	pfi.hasResFork = SwapShort(pfi.hasResFork)	pfi.numResBytes = SwapLong(pfi.numResBytes)	pfi.laterVersionFPos = SwapLong(pfi.laterVersionFPos)Endstatic Function PXPReadHeader(refNum, recordType, version, numDataBytes)	Variable refNum	Variable &recordType, &version, &numDataBytes	// & means pass-by-reference		FBinRead/U/F=2 refNum, recordType	FBinRead/U/F=2 refNum, version	FBinRead/U/F=3 refNum, numDataBytes		Variable swapped = 0	if ((recordType & 0xFF00) != 0)		// High byte should be zero.		recordType = SwapShort(recordType)		version= SwapShort(version)		numDataBytes = SwapLong(numDataBytes)		swapped = 1	endif		return swappedEndstatic Function/S GenerateOutputFileName(pathName, proposedFileName, isFormattedText)	String pathName			// Name of Igor symbolic path	String proposedFileName	// Name of file or path to file.	Variable isFormattedText	// 1=formatted, 0=plain	String extension	if (isFormattedText)		// This appears to be binary data (version field of MWFileFormat1 structure)?		extension = "ifn"		// Formatted notebook.	else		extension = "txt"		// Unformatted notebook.	endif	// Find file name that does not clash with existing file	String outputFileName	Variable index = 1	String uniquifier = ""	String existingFileList = IndexedFile($pathName, -1, "????")	do		sprintf outputFileName, "%s%s.%s", proposedFileName, uniquifier, extension		if (WhichListItem(outputFileName, existingFileList) == -1)		// File name not in use?			break		// Done			endif		sprintf uniquifier, "_%d", index		index += 1	while(1)	return outputFileNameEndFunction/S ExtractPackedNotebooks(pathName, fileName)	String pathName		// Name of Igor symbolic path or ""	String fileName			// Name of file or path to file.		String fileNameList = ""		// Semicolon-separated list of files created.		Variable refNum	Variable numBytesInFile	Variable numberOfNotebooks = 0, numberOfProcFiles = 0		Open/R/P=$pathName/Z refNum as fileName	if (V_flag != 0)		Beep		printf "ExtractPackedNotebooks: Bad path or file name.\r"		return "!Error!"	endif		FStatus refNum	numBytesInFile = V_logEOF		Variable recordNum = 0	do		FStatus refNum		Variable filePos = V_filePos		if (filePos >= numBytesInFile)			break			// All done		endif				Variable swapped, recordType, version, numDataBytes		swapped = PXPReadHeader(refNum, recordType, version, numDataBytes)		// Printf "Record number=%d, recordType=%d, numDataBytes=%d\r", recordNum, recordType, numDataBytes				if (recordType == 8)			// Packed notebook or procedure window			STRUCT PackedFileInfo pfi			FBinRead refNum, pfi			if (pfi.version != 100)				SwapPackedFileInfo(pfi)		// Assume wrong-endian and swap bytes.			endif						if (pfi.version == 100)								// Make sure version and endianness are OK.				if (pfi.laterVersionFPos == 0)					// Not superceded by later version?					String data = PadString("", pfi.numDataBytes, 32)					FBinRead refNum, data					Variable isFormattedText = char2num(data[0])==0 || char2num(data[1])==0	// This appears to be binary data (version field of MWFileFormat1 structure)?					Variable packedRefNum					String packedFileName = pfi.winName					Variable createFile = 0					switch(pfi.wType)						case 7:							createFile = 1							numberOfNotebooks += 1							break						case 10:							packedFileName += ".ipf"							numberOfProcFiles += 1							break					endswitch					if (createFile)						String outputFileName = "tempNotebook.ifn"//GenerateOutputFileName(pathName, packedFileName, isFormattedText)						Open/P=$pathName packedRefNum as outputFileName						FBinWrite packedRefNum, data						Close packedRefNum						fileNameList += outputFileName + ";"					endif				endif			endif		endif				FSetPos refNum, filePos + 8 + numDataBytes		// Skip header and data bytes.				recordNum += 1	while(1)		Close refNum		// Printf "Number of notebooks in experiment file: %d\r", numberOfNotebooks		return fileNameListEnd